---
title: 设计模式之美
categories: 笔记
tags:
  - 设计模式
date: 2023-09-10 22:07:42
---
# 设计模式之美

![image-20230910201522908](https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/20230910220737350419_138_image-20230910201522908.png)

### 面向对象

#### 面向对象四大特性

面向对象的四大特性：封装、抽象、继承、多态

尽管很呆，但小公司爱问

封装：访问控制

保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

抽象：面向接口

让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。以便有效地过滤掉不必要关注的信息，处理复杂的系统。

继承和多态：代码复用

只有当符合“is a"的模型，且更具体的，对父类的任何操作都应当对子类合法，才应当用继承。接口类和”鸭子类型“可以在保留多态的拓展性的同时避免继承造成的强耦合。

> 参见Effective C++ 条款32：确定你的public继承塑模出 is-a 关系。
>
> 如果某个函数可施行于某class身上，一定也可施行于其derived classes身上。

#### 面向对象vs面向过程

在实际的面向对象编程中也很难逃出面向过程的编程范式。比如：

**滥用 getter、setter 方法会破坏类的封装。**

用IDE自动生成或者Lombok一把梭确实很省时间，但是有时候也违背了使用getter，setter的初衷，比如无意中引入不应当出现的setter。

**滥用全局变量和全局方法会影响代码的可维护性，增加代码的编译时间。**

原因是把全局变量集中在一起(比如创建一个Constant类)，一旦由于业务需求对其进行增加或修改，依赖它的代码都会受到影响。

对于全局或静态方法，如果极端一点就像C语言中的宏，

**如何避免**

在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。

设计Constants 类、Utils  类时，我们尽量能做到职责单一，定义一些细化的小类，比如  RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils  类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。

#### 接口&抽象类

抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。

> 在C++中，一个所有方法都是纯虚函数，没有数据成员的抽象类显然可以看做是接口。
>
> 参见Effective C++ 条款34：区分接口继承和实现继承。
>
>  接口继承和实现继承不一样。在public继承下，派生类总是继承基类的接口。
>
>  声明一个纯虚函数的目的，是为了让派生类只继承函数接口。
>
> > 如一个Shape类的Draw()方法。
>
>  声明简朴的非纯虚函数的目的，是让派生类继承该函数的接口和缺省实现。
>
> > 如一个Person类的Sleep()方法。
>
>  声明非虚函数的目的，是为了令派生类继承函数的接口及一份强制性实现。
>
> > 如一个继承体系中的getObjectID()方法。
>
> 同时，纯虚函数是可以提供具体实现的，并且用于替代简朴的非纯虚函数，提供更平常更安全的缺省实现。
>
> 用非纯虚函数提供缺省的默认实现：
>
> ```cpp
> class Airplane {
> public:
>     virtual void Fly() {
>         // 缺省实现
>     }
> };
> 
> class Model : public Airplane { ... };
> ```
>
> 这是最简朴的做法，但是这样做会带来的问题是，由于不强制对虚函数的覆写，在定义新的派生类时可能会忘记进行覆写，导致错误地使用了缺省实现。
>
> 使用纯虚函数并提供默认实现：
>
> ```C++
> class Airplane {
> public:
>     virtual void Fly() = 0;
> };
> 
> void Airplane::Fly() {
>         // 缺省实现
> }
> 
> class Model : public Airplane { 
> public:
>     virtual void Fly() override {
>         Airplane::Fly();
>     }
> };
> ```

#### 基于接口而非实现编程

抽象是好的。

> 越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。

我们都知道抽象的好，但如何变抽象呢？

1. 先想好要做什么，再去想怎么做。这也是抽象人的思考方式。

   > 在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。

2. 定义接口时，命名要足够通用，特别不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。

   - 函数的命名不能暴露任何实现细节
   - 封装具体的实现细节
   - 为实现类定义抽象的接口

   > 这一点更加接近具体的实践。原文中举的例子我也踩过类似的坑，所以也把它放在这里：
   >
   > <details>
   > <summary>具体案例</summary>
   >
   > 假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：
   >
   > ```java
   > public class AliyunImageStore {
   >   //...省略属性、构造函数等...
   >   public void createBucketIfNotExisting(String bucketName) {
   >     // ...创建bucket代码逻辑...
   >     // ...失败会抛出异常..
   >   }
   >   public String generateAccessToken() {
   >     // ...根据accesskey/secrectkey等生成access token
   >   }
   >   public String uploadToAliyun(Image image, String bucketName, String accessToken) {
   >     //...上传图片到阿里云...
   >     //...返回图片存储在阿里云上的地址(url）...
   >   }
   >   public Image downloadFromAliyun(String url, String accessToken) {
   >     //...从阿里云下载图片...
   >   }
   > }
   > // AliyunImageStore类的使用举例
   > public class ImageProcessingJob {
   >   private static final String BUCKET_NAME = "ai_images_bucket";
   >   //...省略其他无关代码...
   >   public void process() {
   >     Image image = ...; //处理图片，并封装为Image对象
   >     AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);
   >     imageStore.createBucketIfNotExisting(BUCKET_NAME);
   >     String accessToken = imageStore.generateAccessToken();
   >     imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);
   >   }
   > }
   > ```
   >
   > 代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。
   >
   > 首先，AliyunImageStore  类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和  downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。
   >
   > 其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。代码中用到了generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。
   >
   > 我们可以这样重构：
   >
   > ```java
   > public interface ImageStore {
   >   String upload(Image image, String bucketName);
   >   Image download(String url);
   > }
   > public class AliyunImageStore implements ImageStore {
   >   //...省略属性、构造函数等...
   >   public String upload(Image image, String bucketName) {
   >     createBucketIfNotExisting(bucketName);
   >     String accessToken = generateAccessToken();
   >     //...上传图片到阿里云...
   >     //...返回图片在阿里云上的地址(url)...
   >   }
   >   public Image download(String url) {
   >     String accessToken = generateAccessToken();
   >     //...从阿里云下载图片...
   >   }
   >   private void createBucketIfNotExisting(String bucketName) {
   >     // ...创建bucket...
   >     // ...失败会抛出异常..
   >   }
   >   private String generateAccessToken() {
   >     // ...根据accesskey/secrectkey等生成access token
   >   }
   > }
   > // 上传下载流程改变：私有云不需要支持access token
   > public class PrivateImageStore implements ImageStore  {
   >   public String upload(Image image, String bucketName) {
   >     createBucketIfNotExisting(bucketName);
   >     //...上传图片到私有云...
   >     //...返回图片的url...
   >   }
   >   public Image download(String url) {
   >     //...从私有云下载图片...
   >   }
   >   private void createBucketIfNotExisting(String bucketName) {
   >     // ...创建bucket...
   >     // ...失败会抛出异常..
   >   }
   > }
   > // ImageStore的使用举例
   > public class ImageProcessingJob {
   >   private static final String BUCKET_NAME = "ai_images_bucket";
   >   //...省略其他无关代码...
   >   public void process() {
   >     Image image = ...;//处理图片，并封装为Image对象
   >     ImageStore imageStore = new PrivateImageStore(...);
   >     imagestore.upload(image, BUCKET_NAME);
   >   }
   > }
   > ```
   >
   > **但凡抱着写脚本的心态写代码，就很容易出现这样的问题**，我给我自己的博客文章写了一个上传图文到Github的GUI脚本，就出现了这样的问题：`upload_to_github`方法写死，`hexo`命令写死，甚至上传函数中还硬编码了对GUI的控制。。。中间有一次希望整合为命令行批量上传，就费一些功夫。比如以后想把博客迁移到Hugo，或者更换图床等等，就又需要改动很多代码。
   >
   > 如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口。但大多数情况下还是需要预见变化的。因此学习优秀的框架是如何组织接口的，是非常有益的实践。
   > </details>

